% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/unglue.R
\name{unglue}
\alias{unglue}
\alias{unglue_data}
\title{unglue}
\usage{
unglue(x, patterns, open = "{", close = "}", convert = TRUE)

unglue_data(x, patterns, open = "{", close = "}", convert = TRUE)
}
\arguments{
\item{x}{a character vector to unglue}

\item{patterns}{a character vector or a list of character vectors, if a list,
items will be with a \code{""} separator.}

\item{open}{The opening delimiter.}

\item{close}{The closing delimiter.}

\item{convert}{convert columns of output using \code{utils::type.convert()}}
}
\value{
\code{unglue_data()} returns a data frame, \code{unglue()} returns a list of
1 row data frames.
}
\description{
\code{unglue()} extracts matched substrings using a syntax inspired from \code{glue::glue()}
into a list of data frames. \code{unglue_data()} returns a data frame from a vector,
just as \code{glue::glue_data()} starts from a data frame to return a vector.
}
\details{
Simple cases don't require regex knowledge at all.

To build the relevant regex pattern special characters will be escaped in the
input pattern and the subpatterns will be replaced with \code{(.*?)} if in standard
\code{"{foo}"} form. An alternate regular expression can be provided after \code{=} so that
\code{"{foo=\\d}} will be translated into \code{"(\\d)"}.

Sometimes we might want to use regex to match a part of the text that won't
be extracted, in these cases we just need to omit the name as in \code{"{=\\d}}.
}
\examples{
# using an awample from ?glue::glue
\dontrun{
library(magrittr)
library(glue)
glued_data <- mtcars \%>\% glue_data("{rownames(.)} has {hp} hp")
unglue_data(glued_data, "{rownames(.)} has {hp} hp")
}

facts <- c("Antarctica is the largest desert in the world!",
"The largest country in Europe is Russia!",
"The smallest country in Europe is Vatican!",
"Disneyland is the most visited place in Europe! Disneyland is in Paris!",
"The largest island in the world is Green Land!")
facts_df <- data.frame(id = 1:5, facts)

patterns <- c("The {adjective} {place_type} in {bigger_place} is {place}!",
            "{place} is the {adjective} {place_type=[^ ]+} in {bigger_place}!{=.*}")
unglue_data(facts, patterns)

\dontrun{
# unglue() is more suitable than unglue_data() in pipe chains:
library(tidyverse)
facts_df \%>\%
  mutate(unglued = unglue(facts, patterns)) \%>\%
  unnest()
# though in these cases it can be more convenient to use the more compact
# and dependence free `unglue_unnest`
}

sentences <- c("666 is [a number]", "foo is [a word]",
              "42 is [the answer]", "Area 51 is [unmatched]")
patterns <- c("{number=\\\\d+} is [{what}]", "{word=\\\\D+} is [{what}]")
unglue_data(sentences, patterns)


}
\seealso{
unglue_unnest
}
